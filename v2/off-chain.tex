\section{Off-chain protocols}
\subsection{Ledger Channels}

A \textbf{ledger} channel is a channel which is funded directly by the ledger.
For simplicity of discussion, we assume that ledger channels operate under the consensus app described in Subsection \ref{sec:applications}, and assume that peers.

This choice is inefficient, and provides suboptimal \timeToPayment in the worst case, since. Efficient designs which achieve best-possible results even in the worst case appear to be viable. Their practical implementation is a problem of current research.

\subsubsection{Depositing into a ledger channel}
(Provide minimal explanation, and refer to the Nitro whitepaper for details.)

\subsubsection{Withdrawing from a ledger channel}

\subsection{Virtual channels}\label{sub:virtual-funding}
Suppose we have peers $A = P_0, P_1, ..., P_n, P_{n+1} = B$ where:
\begin{itemize}
    \item each $(P_i, P_{i+1})$ pair already has a ledger channel $L_i$ running the consensus app
    \item Alice ($P_0$) and Bob ($P_{n+1}$) want to make (virtual) payments between each other.
\end{itemize}

We can safely fund a joint channel $J$ with the following protocol:

\textbf{Round 1}: Each participant signs a state $s$ for $J$ with $turnNum = 0$ and outcome $[\allocation{A}{a_0}, \allocation{B}{b_0}]$. They sign $s$ and send to each participant.

\textbf{Round 2}: For each i = 0,...,n, participants $P_i$ and $P_{i+1}$ sign and exchange an update in $L_i$ to:
\begin{itemize}
    \item deduct $a_0$ from $P_i$'s balance in $L_i$
    \item deduct $b_0$ from $P_{i+1}$'s balance in $L_i$
    \item include the guarantee $G_i = \guarantee{J}{x}{P_i, P_{i+1}}$
\end{itemize}


For instance, $L_i$'s outcome might change
\begin{itemize}
    \item from $[\allocation{P_i}{bal_i}, \allocation{P_{i+1}}{bal_i'}, \guarantee{X'}{x'}{foo, bar}]$
    \item to
$[\allocation{P_i}{bal_i - a_0}, \allocation{P_{i+1}}{bal_i' - b_0}, \guarantee{X'}{x'}{P_i, P_{i+1}}, \guarantee{X}{x}{P_i, P_{i+1}}].$
\end{itemize}


\textbf{Round 3}:
Alice blocks until she receives a counter-signed update in $L_0$. Bob blocks until he receives a counter-signed update in $L_n$. For $i \in \{1,\ldots,n\}$, $P_i$ blocks until they have counter-signed updates in $L_i$.

Once unblocked, each participant signs a post-fund state $s_1$ for $J$ with $\version = 1$ and outcome $[\allocation{A}{a_0}, \allocation{B}{b_0}]$.

For each peer, the protocol is completed once a full set of signatures is received on $s_1$. At this point,
\begin{itemize}
    \item each $P_i$ has $a_0 + b_0$ fewer tokens across their two ledger channels $L_{i-1}$ and $L_i$
    \item Alice ($P_0$) has $a_0$ fewer tokens in $L_0$
    \item Bob ($P_{n+1}$) has $b_0$ fewer tokens in $L_{n}$
    \item every participant's ledger channel reductions are offset by an equal allocation to the joint channel $J$
    % \item $J$'s outcome
\end{itemize}

Before securing this protocol, we observe some properties of this protocol and its derivatives:
\begin{itemize}
    \item The happy path requires $O(n)$ network overhead and $O(1)$ time to complete across $n$ intermediaries. This improves on \ref{perun:mpvcs}\todo{reference perun}, and matches \ref{donner}. \todo{reference Donner}
    \item In the event of an unresponsive or malicious peer, exactly one participant has to launch a challenge for the $J$ channel. Only peers ``connected'' to the faulty peer need to challenge in their ledger channel with their peer. Thus, we acheive the same sad-case complexity as \ref{perun:mpvcs}.\todo{missing ref}
    \item In a unidirectional virtual channel -- one where Bob initially deposits 0 -- it is possible to eliminate Round 3. \todo{Explain how}
    \item At least in the case of one intermediary, rounds 1 \& 2 can be partially combined -- see section \ref{sec:optimization}\todo{fix ref}. The end result is, Bob can redeem payments from Alice after \textbf{two sequential networking messages}. As far as we are aware, this is state of the art, and appears to achieve a theoretical minimum.
\end{itemize}
\begin{conjecture}
    A trustless virtual state channel protocol requires at least two sequential network messages to be funded.
\end{conjecture}

To secure this protocol, we now specify application rules for $J$. \todo{specify}
% https://www.notion.so/statechannels/Nitro-V2-Spec-adccc980d52142d29cbf7f7c7878c2bd#72d52d6cee73494ba7ff60854bcce79b


We are now ready to state the main result of this paper:
\begin{theorem}
    For each $i$, if $P_i$ 
\end{theorem}

Proof: \todo{see V2 spec}

Case 1:
Case 2:
Case 3:

% \begin{cases}
%     \item{}
% \end{cases}

\subsection{Variations}

\subsubsection{Generic virtual channels.}
\todo{see the example on github}

\subsection{Reduced latency of construction.}\label{sec:optimization}
\todo{}
